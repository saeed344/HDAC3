# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y-aZukeTAAwV5MySxPLnoE2B2c5v5YBz
"""

from google.colab import drive
drive.mount('/content/drive')

import itertools
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
import pandas as pd
import math

def categorical_probas_to_classes(p):
    return np.argmax(p, axis=1)

def to_categorical(y, nb_classes=None):
    '''Convert class vector (integers from 0 to nb_classes)
    to binary class matrix, for use with categorical_crossentropy.
    '''
    y = np.array(y, dtype='int')
    if not nb_classes:
        nb_classes = np.max(y)+1
    Y = np.zeros((len(y), nb_classes))
    for i in range(len(y)):
        Y[i, y[i]] = 1.
    return Y


def calculate_performace(test_num, pred_y, labels):
    tp = 0
    fp = 0
    tn = 0
    fn = 0
    for index in range(test_num):
        if labels[index] == 1:
            if labels[index] == pred_y[index]:
                tp = tp + 1
            else:
                fn = fn + 1
        else:
            if labels[index] == pred_y[index]:
                tn = tn + 1
            else:
                fp = fp + 1

    acc = float(tp + tn) / test_num
    precision = float(tp) / (tp + fp + 1e-06)
    npv = float(tn) / (tn + fn + 1e-06)
    sensitivity = float(tp) / (tp + fn + 1e-06)
    specificity = float(tn) / (tn + fp + 1e-06)
    mcc = float(tp * tn - fp * fn) / (math.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn)) + 1e-06)
    f1 = float(tp * 2) / (tp * 2 + fp + fn + 1e-06)
    return acc, precision, npv, sensitivity, specificity, mcc, f1



# Commented out IPython magic to ensure Python compatibility.
from scipy import interp
from sklearn.preprocessing import scale
import pandas as pd
import numpy as np
from tensorflow.keras.models import Sequential, model_from_json
from keras.layers import Flatten
from keras.layers import Conv1D, MaxPooling1D
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import StratifiedKFold

from keras.layers import Dense,Input,Dropout

def get_CNN_model(input_dim,out_dim):
    model = Sequential()
    model.add(Conv1D(filters = 128, kernel_size = 3, padding = 'same', activation= 'relu'))
    model.add(MaxPooling1D(pool_size=2,strides=1,padding="SAME"))
    model.add(Conv1D(filters = 32, kernel_size =  3, padding = 'same', activation= 'relu'))
    model.add(MaxPooling1D(pool_size=2,strides=1,padding="SAME"))
    model.add(Flatten())
    model.add(Dense(int(input_dim/4), activation = 'relu'))
    model.add(Dense(int(input_dim/8), activation = 'relu'))
    model.add(Dense(out_dim, activation = 'softmax',name="Dense_2"))
    model.compile(loss = 'categorical_crossentropy', optimizer = 'Adam', metrics =['accuracy'])
    return model


#model.add(Dense(2, activation='sigmoid', name="Dense_2"))
#model.compile(loss='binary_crossentropy', optimizer='Adam', metrics=['accuracy'])  # rmsprop
###########################
#Load data
path = "/content/drive/MyDrive/QSAR/Update_2/Other_classifiers/"
data_=pd.read_csv(path+'data/X_train_rfe_EN.csv',header=None)
data=np.array(data_)
data = data
[m1, n1] = np.shape(data)
# label1 = np.ones((int(m1 / 2), 1))
# label2 = np.zeros((int(m1 / 2), 1))
# label = np.append(label1, label2)
# shu = scale(data)
X = data
labels = pd.read_csv(path+'data/y_train_rfe_EN.csv',header=None).values

# Convert 'active' to 1 and 'inactive' to 0
# labels['Activity'] = labels['Activity'].map({'active': 1, 'inactive': 0})
# y = labels['Activity'].values
y = labels

# X = np.reshape(X1, (-1, 1, n1))
sepscores = []
ytest = np.ones((1, 2)) * 0.5
yscore = np.ones((1, 2)) * 0.5


sepscores = []
sepscores_ = []
ytest=np.ones((1,2))*0.5
yscore=np.ones((1,2))*0.5

[sample_num,input_dim]=np.shape(X)
out_dim=2
ytest=np.ones((1,2))*0.5
yscore=np.ones((1,2))*0.5
probas_cnn=[]
tprs_cnn = []
sepscore_cnn = []
skf= StratifiedKFold(n_splits=5,shuffle=True)
for i, (train, test) in enumerate (skf.split(X,y)):
    clf_cnn = get_CNN_model(input_dim,out_dim)
    X_train_cnn=np.reshape(X[train],(-1,1,input_dim))
    X_test_cnn=np.reshape(X[test],(-1,1,input_dim))
    y_test=to_categorical(y[test])
    ytest=np.vstack((ytest,y_test))
    y_test_tmp=y[test]
    history = clf_cnn.fit(X_train_cnn, to_categorical(y[train]),validation_data=(X_test_cnn, y_test),epochs=25)
    y_cnn_probas=clf_cnn.predict(X_test_cnn)
    probas_cnn.append(y_cnn_probas)
    y_class= categorical_probas_to_classes(y_cnn_probas)
    yscore=np.vstack((yscore,y_cnn_probas))

    acc, precision,npv, sensitivity, specificity, mcc,f1 = calculate_performace(len(y_class), y_class,y[test])
    mean_fpr = np.linspace(0, 1, 100)
    fpr, tpr, thresholds = roc_curve(y[test], y_cnn_probas[:, 1])
    tprs_cnn.append(interp(mean_fpr, fpr, tpr))
    tprs_cnn[-1][0] = 0.0
    roc_auc = auc(fpr, tpr)
    sepscore_cnn.append([acc, precision,npv, sensitivity, specificity, mcc,f1,roc_auc])
    print('CNN:acc=%f,precision=%f,npv=%f,sensitivity=%f,specificity=%f,mcc=%f,f1=%f,roc_auc=%f'
          % (acc, precision,npv, sensitivity, specificity, mcc,f1, roc_auc))
    # clf_cnn.save('weights/' + str(i) + 'Lastepoch_new.h5')
# serialize model to JSON
model_json = clf_cnn.to_json()
with open(path+"DL_results/CNN_model.json", "w") as json_file:
    json_file.write(model_json)
# serialize weights to HDF5
clf_cnn.save_weights(path+"DL_results/CNN_model.h5")
print("Saved model to disk")

row=ytest.shape[0]
ytest=ytest[np.array(range(1,row)),:]
ytest_sum = pd.DataFrame(data=ytest)
ytest_sum.to_csv(path+'DL_results/CNN_ytest.csv')

yscore_=yscore[np.array(range(1,row)),:]
yscore_sum = pd.DataFrame(data=yscore_)
yscore_sum.to_csv(path+'DL_results/CNN_yscore.csv')

scores=np.array(sepscore_cnn)
result1=np.mean(scores,axis=0)
H1=result1.tolist()
sepscore_cnn.append(H1)
result=sepscore_cnn
data_csv = pd.DataFrame(data=result)
data_csv.to_csv(path+'DL_results/CNN_results_CV.csv')
print(history)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model accuracy')
plt.ylabel('Accuracy_loss')
plt.xlabel('Epoch')
plt.show()
